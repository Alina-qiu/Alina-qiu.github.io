{"meta":{"title":"Alina Blog","subtitle":"","description":"","author":"Alina","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2020-08-12T18:09:57.681Z","updated":"2020-08-12T18:09:57.682Z","comments":true,"path":"2020/08/13/hello-world/","link":"","permalink":"http://yoursite.com/2020/08/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"HTML插入图片与CSS背景图片的区别","slug":"插入图片与背景图片的区别","date":"2020-08-12T06:37:10.000Z","updated":"2020-08-16T16:06:33.153Z","comments":true,"path":"2020/08/12/插入图片与背景图片的区别/","link":"","permalink":"http://yoursite.com/2020/08/12/%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E4%B8%8E%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"1、插入图片img为行内块元素，是一个盒子模型，占文档流的位置，图片加载出错时会出现红叉； ​ 背景图片不占文档流，在图片加载失败时，不会有占位标记，图片加载出错时不会出现红叉。 2、插入图片移动位置通过margin 和 padding实现； ​ 背景图片移动通过background-position移动。 3、插入图片更改大小通过width 和 height实现； ​ 背景图片只能通过background-size。 4、插入图片一般用在产片展示类，背景图片用于小图标背景或者超大背景图片。 5、盒子中使用背景图片需要注意盒子尺寸和背景图片尺寸匹配。 6、直接插入图片会多出4px，设置背景图片给定高度不会 ​ 去除图片底侧缝隙(低版本浏览器)： ​ 解决方法一：给img添加display: block; 转换为块级元素 ​ 解决方法二：给img添加vertical-align: middle | top 7、css中的图片以背景图形式存在，写在html中的图片以标签形式存在。在网页加载过程中，以css背景存在的图片会等到html结构加载完成才开始加载； 而html中的img标签是网页结构（内容）的一部分会在加载结构的过程中加载。 8、在一个单纯由HTML和CSS组成的页面中，背景图片总是最后加载的，那么假若想要使用较小的背景图片作为占位符，用于在加载较大的图片或者Flash文件时给用户以提示，大部分时候恐怕是达不到效果的，因为背景图片有时甚至会在大图片或Flash文件加载完成之后才会被加载。 9、通常非内容的图片（即用来修饰页面的元素）就写在css里，如果是内容性的图片就写在html中。比如，你要做一个漂亮相框的相册，那么修饰边框的图片就写在css里，相框里的内容照片就写在html中。","categories":[],"tags":[]},{"title":"闭包","slug":"闭包","date":"2018-12-18T14:17:01.000Z","updated":"2020-08-18T03:52:11.835Z","comments":true,"path":"2018/12/18/闭包/","link":"","permalink":"http://yoursite.com/2018/12/18/%E9%97%AD%E5%8C%85/","excerpt":"","text":"1、什么是闭包？当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 —你不知道的JavaScript(上卷) 123456789function demo() &#123; var a = 1; return function () &#123; return a; &#125;&#125;var a = demo();console.log(a()); // 1 2、闭包的构成闭包由两部分构成：函数，以及创建该函数的环境。 环境由闭包创建时在作用域中的任何局部变量组成。 3、闭包的本质闭包其实是JavaScript函数作用域的副作用产品。 闭包是一种特殊的对象。 所谓有意栽花花不开,无心插柳柳成荫，不是JavaScript故意要使用闭包，而是由于JavaScript的函数内部可以使用函数外部的变量，这段代码又刚刚好符合闭包的定义。 在JavaScript中，外部函数调用之后其变量对象本应该被销毁，但闭包阻止了它们的销毁，我们仍然可以访问外部函数的变量对象。 进一步的说，通常情况下，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，如果创建了一个闭包的话，这个函数的作用域就会一直保存到闭包不存在为止。 1234567891011121314function addCalculator (x) &#123; return function (y) &#123; return x + y; &#125;&#125;var add1 = addCalculator(1);console.log(add1(1)); //2// 释放对闭包的引用add1 = null;console.log(add1(1)); //Uncaught TypeError: add1 is not a function 4、闭包的应用我们可以用闭包来做什么呢？ 了解Java的同学可能知道，Java是支持私有方法的，私有方法只能被一个类中的其他方法所调用，但是JavaScript没有提供这种原生支持，所以我们可以通过闭包来模拟私有方法。 私有方法自然有私有方法的好处，私有方法有利于限制对代码的访问，而且可以避免非核心的方法干扰代码的公共接口，减少全局污染。 1234567891011121314151617181920212223var calculator = (function()&#123; var a = 1; function addCalculator(val)&#123; a += val &#125; return &#123; add1:function() &#123; addCalculator(1); &#125;, add2:function() &#123; addCalculator(2); &#125;, result:function() &#123; return a &#125; &#125;&#125;)();console.log(calculator.result()); // 1calculator.add1();console.log(calculator.result()); // 2calculator.add2();console.log(calculator.result()); // 4 上面这种方式也叫做**模块模式(module pattern)**。 5、使用闭包的注意事项内存泄漏 因为闭包可以使函数中的变量都保存在内存中，造成很大的内存消耗，所以如果不是某些特定的任务需要使用闭包，我们不要滥用它。 很多博客中都提到了这一点，但是其实都是不完全对的。 敲黑板！！！ 使用不当的闭包会在IE(IE9)之前造成内存泄漏问题。因为它的JavaScript引擎使用的垃圾回收算法是引用计数法，对于循环引用将会导致GC(下文会介绍)无法回收垃圾。 关于各个浏览器的闭包测试，详情请见： 司徒正美-js闭包测试 https://www.cnblogs.com/rubylouvre/p/3345294.html 6、垃圾回收机制垃圾回收也就是GC(Garbage Collection) GC把程序不用的内存空间视为垃圾，找到它们并且将它们回收，让程序员可以再次利用这部分空间。 不是所有的语言都有GC，一般存在于高级语言中，如Java、JavaScript、Python。那么在没有GC的世界里，程序员就比较辛苦，只能手动去管理内存，比如在C语言中我们可以通过malloc/free，在C++中的new/delete来进行管理。 7、垃圾回收算法因为这一部分的内容很多，本文只进行简单的讲解，如果想深入了解垃圾回收算法的同学可以在文末获取学习资料。 GC标记-清除算法 世界上首个值得纪念的GC算法是GC标记-清除算法。因为自其问世以来，一直到半个世纪后的今天，它依然是各种处理程序所用的伟大的算法。 GC标记-清除算法由标记阶段和清除阶段构成，标记阶段将所有的活动对象做上相应的标记，清除阶段把那些没有标记的对象，也就是非活动对象进行回收。在搜索对象并进行标记的时候使用了深度优先搜索，尽可能的从深度上搜索树形结构。 优点 1.算法简单，实现容易。 2.与保守式的GC算法兼容。 缺点： 1.在使用过程中会出现碎片化的情况，如同Windows的文件系统一样，导致无数的小分块散布在堆的各个地方。 2.分配速度，由于分块的不连续性，算法每次分配的时候都需要遍历空闲链表为了找到足够大的分块，这样最糟糕的情况就是遍历到最后才找到合适的分块，影响了分配速度。 引用计数法 这种方法中引入了计数器的概念，通过计数器来表示对象的“人气指数”，也就是有多少个程序引用了这个对象。当计数器(引用数)为0时，垃圾立刻被回收。 优点: 1.可以立即回收垃圾。 2.最大暂停的时间短。 3.并且没有必要沿指针查找。 缺点: 1.上文提到过的循环引用无法回收。 2.并且实现起来很复杂。 3.计数器值的增减处理十分繁重。 4.同时计数器需要占很多位，导致内存空间的使用效率大大降低。 软件工程没有银弹，这些缺点也都有相应的办法进行解决，如果你想深入了解垃圾回收算法，可以学习这本书，建议支持正版。 垃圾回收的算法与实现 https://book.douban.com/subject/26821357/","categories":[],"tags":[{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"}]}],"categories":[],"tags":[{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"}]}