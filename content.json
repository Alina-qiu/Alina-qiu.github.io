{"meta":{"title":"Alina Blog","subtitle":"","description":"","author":"Alina","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"babel归纳总结","slug":"babel归纳总结","date":"2020-04-19T07:15:45.000Z","updated":"2020-09-08T10:16:46.186Z","comments":true,"path":"2020/04/19/babel归纳总结/","link":"","permalink":"http://yoursite.com/2020/04/19/babel%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/","excerpt":"","text":"一、babel是什么babel是将目标环境（浏览器）通过打补丁升级成支持最新javascript语法的环境的工具。babel就是处理兼容的转译工具。 babel的编译过程分为3步，解析（parse），转换（transform），生成（generate），对应的三个插件分别是Babylon、babel-traverse、babel-generator。babylon将源码转换为抽象语法树（AST）； babel-traverse通过AST生成一个便于操作、转换的path对象，供我们的babel插件处理； babel-generator读取AST并将其转换为代码和源码映射。 二、通过vue中的babel配置来了解babelvue脚手架生成的项目在.babelrc文件中的配置： 123456789101112&#123; &quot;presets&quot;: [ [&quot;env&quot;, &#123; &quot;modules&quot;: false, &quot;targets&quot;: &#123; &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;] &#125; &#125;], &quot;stage-2&quot; ], &quot;plugins&quot;: [&quot;transform-vue-jsx&quot;, &quot;transform-runtime&quot;]&#125; plugin配置项babel插件推崇的是功能的单一性，就是每个插件的功能尽可能的单一，比如要使用es6的箭头函数，那就可以装一个转换插件npm i -D @babel/plugin-transform-arrow-functions，将其写进.babelrc文件里就行了：详情 1234&#123; &quot;presets&quot;: [], &quot;plugins&quot;: [&quot;@babel/plugin-transform-arrow-functions&quot;]&#125; 这样，我们写的： 1(a) =&gt; [...a] 会被该插件转换为： 123function (a) &#123; return [...a]&#125; presets配置项然而，js发展很快，每一次版本的更新都会添加很多东西，如果一个个设置就很麻烦，所以就可以采用presets配置项。npm i -D babel-preset-es2015，然后配置.babelrc。详情 这里暂时先用babel6的写法，babel7里也可以用babel-preset-es2015，但是文档里去掉了，es2015、es2016、es2017（2018年的东西直接写在env里了，7月份2019年的新标准就要来罗@_@）等都被放在env里面了，以后这几个preset会不会砍掉就不知道咯。 1234&#123; &quot;presets&quot;: [&quot;es2015&quot;], &quot;plugins&quot;: []&#125; 这样我们就可以使用包括箭头函数在内的es6的新语法而不用去担心兼容问题。这下这两个的关系也就清晰了，**presets里面配置的是一些plugins集合** 在babel 7.3.0里面，presets – 对应插件有这些： env – @babel/preset-env stage-0 – @babel/preset-stage-0 stage-1 – @babel/preset-stage-1 stage-2 – @babel/preset-stage-2 stage-3 – @babel/preset-stage-3 flow – @babel/preset-flow react – @babel/preset-react minify – babel-preset-minify typescript – @babel/preset-typescript env在presets配置里面，我们看到了： 123456[&quot;env&quot;, &#123; &quot;modules&quot;: false, &quot;targets&quot;: &#123; &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;] &#125;&#125;] 这个env是@babel/preset-env这个集合插件配置项，这里的配置项： modules：”amd” | “umd” | “systemjs” | “commonjs” | “cjs” | “auto” | false, defaults to “auto”. 意思就是让babel把es6 模块转化为其它模块化类型。如果选择 false 就不进行模块化转，我们的目标是浏览器，es6以前js是没有模块化的，commonjs、amd等只是社区方案，没有浏览器支持的，所以我们设置为false，如果我们写node上运行的代码，就要设置为”commonjs” target：就是告诉babel你的js要兼容哪些环境，它会帮你将你写的js转译成目标环境兼容的js语法，这个具体配置可以看browserslist js无论用什么新语法，@babel/preset-env都能帮你兼容到目标环境。 @babel/preset-env具体可以帮我们转化哪些呢？看这儿JavaScript新特性和Babel插件的映射关系，这个是@babel/preset-env集合插件所包含的插件列表，每个插件对应转换一个新特性。 stage-2在上面的配置中，我们看到env下面有个stage-2。stage-x，这里面包含的都是当年最新规范的草案，每年更新。细分为如下几步 Stage 0 - 稻草人: 只是一个想法，经过 TC39 成员提出即可。 Stage 1 - 提案: 初步尝试。 Stage 2 - 初稿: 完成初步规范。 Stage 3 - 候选: 完成规范和浏览器初步实现。 Stage 4 - 完成: 将被添加到下一年度发布。 官网里有一句话It is important to note that @babel/preset-env does not support stage-x plugins.，就是说@babel/preset-env中不包含在草案阶段的新属性的转换插件 其实我们通过plugin-features，以及proposals/finished-proposals（其中2019就是今年的stage-4）,可以发现@babel/preset-env是包含了stage-4阶段的plugins的。 比如写react的同学比较熟悉的decorators目前就处于stage-2阶段，我们要用这些处于草案阶段的新属性，可以安装npm i -D @babel/preset-stage-2，然后在presets里写上stage-2，babel就会通过那些处于草案阶段的新属性的插件将我们代码中的用到的新属性转译成为es5。 此外，低一级的 stage 会包含所有高级 stage 的内容，例如 stage-2 会包含 stage-2, stage-3 的所有内容。 babel-ployfillBabel 几乎可以编译所有时新的 JavaScript 语法，但对于 APIs 来说却并非如此。比如说：Promise、WeakMap、Array.from 、Object.assign、Array.prototype.includes、generator等。为了解决这个问题，我们使用一种叫做 Polyfill（代码填充，也可译作兼容性补丁） 的技术。能让你提前使用还不可用的 APIs。 引入它很简单，我们npm i -S @babel/polyfill， 在vue中的入口文件main.js文件的最上面： 1import &quot;@babel/polyfill&quot;; 或者在webpack入口里引入： 123module.exports = &#123; entry: [&quot;@babel/polyfill&quot;, &quot;./main.js&quot;],&#125;; 两者任选其一 上面这两种方式是将整个polyfill都引入了，很多代码其实对我们是没有用的，比如，我们的env配置的是不需要兼容ie9以下的浏览器，这种引入方式把所有兼容ie的代码都引入了，包含ie8以下，所以，一般我们会在.babelrc文件里的env里配置下useBuiltIns参数，这样babel在引入的时候会根据我们env环境去加载相应的polyfill：详细 有如下三种方式 如果在 .babelrc 中设置 useBuiltIns: ‘usage’，则不要在 webpack.config.js entry 数组或 源码中包含 @babel/polyfill。注意，仍然需要安装 babel-polyfill（就是说 npm i -S @babel/polyfill后就不管了）。 如果在 .babelrc 中设置 useBuiltIns: ‘entry’，在应用程序入口（main.js）的顶部引入 @babel/polyfill。 如果在 .babelrc 中没有明确设置useBuiltIns的值（就是你没有去配置这项）或者设置了 useBuiltIns: false，将 @babel/polyfill 添加到 webpack.config.js 的入口数组中。 1234567891011121314151617// .babelrc&#123; [&quot;env&quot;, &#123; &quot;modules&quot;: false, &quot;targets&quot;: &#123; &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;] &#125;, // 是否自动引入polyfill，开启此选项必须保证已经安装了babel-polyfill // 在这里设置自动引入后，babel会根据你配置的兼容的环境，去按需加载polyfill的代码，这样能保证代码量最少 // 参数：Boolean，默认为false. &quot;useBuiltIns&quot;: false &#125;]&#125;// webpack.base.conf.jsmodule.exports = &#123; entry: [&quot;@babel/polyfill&quot;, &quot;./main.js&quot;],&#125;; @babel/plugin-transform-runtime一个插件，通过重复使用babel注入的助手（helper）代码，来减少代码体积，我们看看它是如何工作的。 12345678910111213141516npm i -D @babel/plugin-transform-runtime// .babelrc&#123; &quot;plugins&quot;: [ &quot;@babel/plugin-transform-runtime&quot;, // 默认配置 &#123; &quot;absoluteRuntime&quot;: false, &quot;corejs&quot;: false, &quot;helpers&quot;: true, &quot;regenerator&quot;: true, &quot;useESModules&quot;: false &#125; ]&#125; 比如这个es6的class类：在没有使用transform-runtime时，每个使用class函数处，Babel 会生成class的helper函数放置在文件顶部，就是说在多个文件里使用了class, babel就会在每个文件里面都生成相同的helper： 1234567&quot;use strict&quot;;function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123;throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125; &#125;var Person = function Person() &#123; _classCallCheck(this, Person);&#125;; 这样不必要的重复会使我们的代码体积非常雍肿，transform-runtime就是来解决这个重复生成helper的问题的，它会将这个es6的class语法的helper函数放在babel-runtime/helpers里，然后在使用处通过require引入，这样就没必要在每个使用处重复定义helper了，达到了减少代码体积的效果。 1234567891011&quot;use strict&quot;;var _classCallCheck2 = require(&quot;babel-runtime/helpers/classCallCheck&quot;);var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;var Person = function Person() &#123; (0, _classCallCheck3.default)(this, Person);&#125;; @babel/runtime 对比 babel-polyfill@babel/runtime和@babel/polyfill这两个模块功能几乎相同，就是转码新增 api @babel/polyfill 把原生的方法重写了，以promise为例，判断环境promise存不存在，不存在就写个全局作用域的promise。它会一次引入所有的api的polyfill，只是根据env配置引入的包大小可能会不同。 @babel/runtime 是写了个helper函数，以promise为例，你代码中的promise都会被换成_promise，然后babel会生成一个_promise helper函数，大致也是目标环境存在就用原生的，不存在就用polyfill的promise。而且这个是按需引入的，如果你的项目中只使用了promise，就只会引入promise的polyfill。但是它有个问题，实例上的方法无能为力，比如 Array上的form方法，String上的includes等 根据它们两的特点，@babel/polyfil一般用于前端项目，@babel/runtime一般用来写插件 三、几个常用的babel插件babel-cliBabel 的 CLI 是一种在命令行下使用 Babel 编译文件的简单方法。有时候我们只是写一个插件，需要用babel转一下我们代码中的高阶语法，因为项目可能不太大，用不到构建工具，就可以用babel-cil。转换依据我们的.babelrc文件或者package.json中babel选项 编译一个文件 1babel my-file.js 如果我们想要把一个目录整个编译成一个新的目录，可以使用 –out-dir 或者 -d。. 123$ babel src --out-dir lib# 或$ babel src -d lib babel-loader前端开发是一个工程化过程，依赖关系比较复杂，在一个稍微大点儿的项目中还真没法手动告诉babel要处理哪些文件。所以，webpack根据依赖关系，加载文件的时候遇到js文件后，会将文件内容的js字符串根据loader配置的先后顺序，挨个儿传递给它们处理，babel-loader就是其中之一。 四、总结用vue脚手架生成的项目，js怎么兼容到ie9123456789101112131415161718192021// .babelrc&#123; &quot;presets&quot;: [ [&quot;env&quot;, &#123; // 这里默认是false，不用再写一遍- // &quot;modules&quot;: false, // 一般不单独写出来，babel/preset-env会自个读取package里面的browserslist，与css兼容环境保持一致 // https://github.com/browserslist/browserslist- // &quot;targets&quot;: &#123;- // &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;]- // &#125;, &#125;], &quot;stage-2&quot; ], &quot;plugins&quot;: [&quot;transform-vue-jsx&quot;, &quot;transform-runtime&quot;] &#125;// webpack.base.conf.jsmodule.exports = &#123; entry: [&quot;@babel/polyfill&quot;, &quot;./main.js&quot;],&#125; 插件快照 名称 作用 备注 babel/cli 允许命令行使用 babel 命令转译文件 一般在写插件时使用 babel/polyfill 为所有 API 增加兼容方法 需要在所有代码之前 require，且体积比较大 babel/plugin-transform-runtime 把帮助类方法从每次使用前定义改为统一 require，精简代码 — babel/runtime helper库 需要安装为依赖，而不是开发依赖，node环境使用，web环境不需要 babel/loader babel插件在webpack项目中的一个入口 — babel/core babel的polyfill库 — babel/preset-env babel预制环境的集合插件，通过配置目标环境，转换标准上的新特性 只转新特性，不转api babel/preset-stage-2 转换草案stage-2以及stage-3阶段的的新属性 —","categories":[],"tags":[{"name":"babel vue-cli vue","slug":"babel-vue-cli-vue","permalink":"http://yoursite.com/tags/babel-vue-cli-vue/"}]},{"title":"JavaScript从原型到原型链","slug":"JavaScript从原型到原型链","date":"2019-01-10T12:17:10.000Z","updated":"2020-08-18T07:04:49.956Z","comments":true,"path":"2019/01/10/JavaScript从原型到原型链/","link":"","permalink":"http://yoursite.com/2019/01/10/JavaScript%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"构造函数创建对象我们先使用构造函数创建一个对象： 123456function Person() &#123; &#125;var person = new Person();person.name = &#x27;name&#x27;;console.log(person.name) // name 在这个例子中，Person就是一个构造函数，我们使用new创建了一个实例对象person。 很简单吧，接下来进入正题： prototype每个函数都有一个prototype属性，就是我们经常在各种例子中看到的那个prototype，比如： 12345678910function Person() &#123; &#125;// 虽然写在注释里，但是你要注意：// prototype是函数才会有的属性Person.prototype.name = &#x27;name&#x27;;var person1 = new Person();var person2 = new Person();console.log(person1.name) // nameconsole.log(person2.name) // name 那这个函数的prototype属性到底指向的是什么呢？是这个函数的原型吗？ 其实，函数的prototype属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型,也就是这个例子中的person1和person2的原型。 那么什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 让我们用一张图表示构造函数和实例原型之间的关系： 在这张图中我们用Object.prototype表示实例原型 那么我们该怎么表示实例与实例原型，也就是person和Person.prototype之间的关系呢，这时候我们就要讲到第二个属性： proto这是每一个JavaScript对象(除了null)都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。 为了证明这一点,我们可以在火狐或者谷歌中输入： 12345function Person() &#123; &#125;var person = new Person();console.log(person.__proto__ === Person.prototype); //true 于是我们更新下关系图： 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：construcotr，每个原型都有一个constructor属性指向关联的构造函数 为了验证这一点，我们可以尝试： 1234function Person() &#123; &#125;console.log(Person === Person.prototype.constructor); //true 所以再更新下关系图： 综上我们已经得出： 123456789function Person() &#123;&#125; var person = new Person(); console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) //true 了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系： 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 举个例子： 12345678910111213function Person() &#123; &#125; Person.prototype.name = &#x27;name&#x27;; var person = new Person(); person.name = &#x27;name of this person&#x27;;console.log(person.name) // name of this person delete person.name;console.log(person.name) // name 在这个例子中，我们设置了person的name属性，所以我们可以读取到为’name of this person’，当我们删除了person的name属性时，读取person.name，从person中找不到就会从person的原型也就是person.proto == Person.prototype中查找，幸运的是我们找到了为’name’，但是万一还没有找到呢？原型的原型又是什么呢？ 在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是 123var obj = new Object();obj.name = &#x27;name&#x27;console.log(obj.name) // name 所以原型对象是通过Object构造函数生成的，结合之前所讲,实例的__proto__指向构造函数的prototype,所以我们再更新下关系图： 原型链那Object.prototype的原型呢？ null，嗯，就是null,所以查到Object.prototype就可以停止查找了 所以最后一张关系图就是 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充最后，补充和纠正本文中一些不严谨的地方： 首先是constructor, 12345function Person() &#123; &#125;var person = new Person();console.log(person.constructor === Person); // true 当获取person.constructor时，其实person中并没有constructor属性,当不能读取到constructor属性时，会从person的原型也就是Person.prototype中读取，正好原型中有该属性，所以 1person.constructor === Person.prototype.constructor 其次是proto, 绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在与Person.prototype中，实际上，它是来自于Object.prototype，与其说是一个属性，不如说是一个getter/setter，当使用obj.__proto__时，可以理解成返回了Object.getPrototypeOf(obj) 最后是关于继承，前面我们讲到“每一个对象都会从原型”继承”属性”,实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：继承意味着复制操作，然而JavaScript默认并不会复制对象的属性，相反，JavaScript只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。","categories":[],"tags":[{"name":"原型","slug":"原型","permalink":"http://yoursite.com/tags/%E5%8E%9F%E5%9E%8B/"}]},{"title":"闭包","slug":"闭包","date":"2018-12-18T14:17:01.000Z","updated":"2020-08-18T03:52:11.835Z","comments":true,"path":"2018/12/18/闭包/","link":"","permalink":"http://yoursite.com/2018/12/18/%E9%97%AD%E5%8C%85/","excerpt":"","text":"1、什么是闭包？当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 —你不知道的JavaScript(上卷) 123456789function demo() &#123; var a = 1; return function () &#123; return a; &#125;&#125;var a = demo();console.log(a()); // 1 2、闭包的构成闭包由两部分构成：函数，以及创建该函数的环境。 环境由闭包创建时在作用域中的任何局部变量组成。 3、闭包的本质闭包其实是JavaScript函数作用域的副作用产品。 闭包是一种特殊的对象。 所谓有意栽花花不开,无心插柳柳成荫，不是JavaScript故意要使用闭包，而是由于JavaScript的函数内部可以使用函数外部的变量，这段代码又刚刚好符合闭包的定义。 在JavaScript中，外部函数调用之后其变量对象本应该被销毁，但闭包阻止了它们的销毁，我们仍然可以访问外部函数的变量对象。 进一步的说，通常情况下，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，如果创建了一个闭包的话，这个函数的作用域就会一直保存到闭包不存在为止。 1234567891011121314function addCalculator (x) &#123; return function (y) &#123; return x + y; &#125;&#125;var add1 = addCalculator(1);console.log(add1(1)); //2// 释放对闭包的引用add1 = null;console.log(add1(1)); //Uncaught TypeError: add1 is not a function 4、闭包的应用我们可以用闭包来做什么呢？ 了解Java的同学可能知道，Java是支持私有方法的，私有方法只能被一个类中的其他方法所调用，但是JavaScript没有提供这种原生支持，所以我们可以通过闭包来模拟私有方法。 私有方法自然有私有方法的好处，私有方法有利于限制对代码的访问，而且可以避免非核心的方法干扰代码的公共接口，减少全局污染。 1234567891011121314151617181920212223var calculator = (function()&#123; var a = 1; function addCalculator(val)&#123; a += val &#125; return &#123; add1:function() &#123; addCalculator(1); &#125;, add2:function() &#123; addCalculator(2); &#125;, result:function() &#123; return a &#125; &#125;&#125;)();console.log(calculator.result()); // 1calculator.add1();console.log(calculator.result()); // 2calculator.add2();console.log(calculator.result()); // 4 上面这种方式也叫做**模块模式(module pattern)**。 5、使用闭包的注意事项内存泄漏 因为闭包可以使函数中的变量都保存在内存中，造成很大的内存消耗，所以如果不是某些特定的任务需要使用闭包，我们不要滥用它。 很多博客中都提到了这一点，但是其实都是不完全对的。 敲黑板！！！ 使用不当的闭包会在IE(IE9)之前造成内存泄漏问题。因为它的JavaScript引擎使用的垃圾回收算法是引用计数法，对于循环引用将会导致GC(下文会介绍)无法回收垃圾。 关于各个浏览器的闭包测试，详情请见： 司徒正美-js闭包测试 https://www.cnblogs.com/rubylouvre/p/3345294.html 6、垃圾回收机制垃圾回收也就是GC(Garbage Collection) GC把程序不用的内存空间视为垃圾，找到它们并且将它们回收，让程序员可以再次利用这部分空间。 不是所有的语言都有GC，一般存在于高级语言中，如Java、JavaScript、Python。那么在没有GC的世界里，程序员就比较辛苦，只能手动去管理内存，比如在C语言中我们可以通过malloc/free，在C++中的new/delete来进行管理。 7、垃圾回收算法因为这一部分的内容很多，本文只进行简单的讲解，如果想深入了解垃圾回收算法的同学可以在文末获取学习资料。 GC标记-清除算法 世界上首个值得纪念的GC算法是GC标记-清除算法。因为自其问世以来，一直到半个世纪后的今天，它依然是各种处理程序所用的伟大的算法。 GC标记-清除算法由标记阶段和清除阶段构成，标记阶段将所有的活动对象做上相应的标记，清除阶段把那些没有标记的对象，也就是非活动对象进行回收。在搜索对象并进行标记的时候使用了深度优先搜索，尽可能的从深度上搜索树形结构。 优点 1.算法简单，实现容易。 2.与保守式的GC算法兼容。 缺点： 1.在使用过程中会出现碎片化的情况，如同Windows的文件系统一样，导致无数的小分块散布在堆的各个地方。 2.分配速度，由于分块的不连续性，算法每次分配的时候都需要遍历空闲链表为了找到足够大的分块，这样最糟糕的情况就是遍历到最后才找到合适的分块，影响了分配速度。 引用计数法 这种方法中引入了计数器的概念，通过计数器来表示对象的“人气指数”，也就是有多少个程序引用了这个对象。当计数器(引用数)为0时，垃圾立刻被回收。 优点: 1.可以立即回收垃圾。 2.最大暂停的时间短。 3.并且没有必要沿指针查找。 缺点: 1.上文提到过的循环引用无法回收。 2.并且实现起来很复杂。 3.计数器值的增减处理十分繁重。 4.同时计数器需要占很多位，导致内存空间的使用效率大大降低。 软件工程没有银弹，这些缺点也都有相应的办法进行解决，如果你想深入了解垃圾回收算法，可以学习这本书，建议支持正版。 垃圾回收的算法与实现 https://book.douban.com/subject/26821357/","categories":[],"tags":[{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"this的值","slug":"this的值","date":"2018-11-15T12:22:06.000Z","updated":"2020-09-08T10:17:08.885Z","comments":true,"path":"2018/11/15/this的值/","link":"","permalink":"http://yoursite.com/2018/11/15/this%E7%9A%84%E5%80%BC/","excerpt":"","text":"函数调用首先需要从函数的调用开始讲起。 JS（ES5）里面有三种函数调用形式： 123func(p1, p2)obj.child.method(p1, p2)func.call(context, p1, p2) // 先不讲 apply 一般，我们都知道前两种形式，而且认为前两种形式「优于」第三种形式。 从看到这篇文章起，一定要记住，第三种调用形式，才是正常调用形式： 1func.call(context, p1, p2) 其他两种都是语法糖，可以等价的变为call形式： 12345func(p1, p2) 等价于func.call(undefined, p1, p2) obj.child.method(p1, p2) 等价于obj.child.method.call(obj.child, p1, p2) 此代码为「转换代码」。 至此我们的函数调用只有一种形式： 1func.call(context, p1, p2) 这样，this 就好解释了。 this，就是上面代码中的 context。就这么简单。 this 是你 call 一个函数时传的 context，由于你从来不用 call 形式的函数调用，所以你一直不知道。 先看 func(p1, p2) 中的 this 如何确定： 当你写下面代码时： 12345function func()&#123; console.log(this)&#125; func() 等价于： 12345function func()&#123; console.log(this)&#125; func.call(undefined) // 可以简写为 func.call() 按理说打印出来的 this 应该就是 undefined 了吧，但是浏览器里有一条规则： 如果传的 context 是 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined） 因此上面的打印结果是 window。 如果希望这里的 this 不是 window，很简单： 1func.call(obj) // 那么里面的 this 就是 obj 对象了 再看 obj.child.method(p1, p2) 的 this 如何确定 1234567var obj = &#123; foo: function()&#123; console.log(this) &#125;&#125; obj.foo() 按照「转换代码」，我们将 obj.foo() 转换为： 1obj.foo.call(obj) 好了，this 就是 obj。搞定。 回到题目： 12345678910111213var obj = &#123; foo: function()&#123; console.log(this) &#125;&#125; var bar = obj.fooobj.foo() // 转换为 obj.foo.call(obj)，this 就是 objbar()// 转换为 bar.call()// 由于没有传 context// 所以 this 就是 undefined// 最后浏览器给你一个默认的 this —— window 对象 []语法123function fn ()&#123; console.log(this) &#125;var arr = [fn, fn2]arr[0]() // 这里面的 this 又是什么呢？ 我们可以把 arr0 想象为arr.0( )，虽然后者的语法错了，但是形式与转换代码里的 obj.child.method(p1, p2) 对应上了，于是就可以愉快的转换了： 1234 arr[0]()假想为 arr.0()然后转换为 arr.0.call(arr)那么里面的 this 就是 arr 了 :) 总结 this 就是 call 一个函数时，传入的 context。 如果函数调用形式不是 call 形式，请按照「转换代码」将其转换为 call 形式。","categories":[],"tags":[{"name":"this","slug":"this","permalink":"http://yoursite.com/tags/this/"}]},{"title":"理解JS作用域","slug":"理解JS作用域","date":"2018-10-28T07:43:37.000Z","updated":"2020-09-08T10:18:19.822Z","comments":true,"path":"2018/10/28/理解JS作用域/","link":"","permalink":"http://yoursite.com/2018/10/28/%E7%90%86%E8%A7%A3JS%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"什么是作用域？作用域是代码在运行时，各个变量、函数和对象的可访问性。换句话说，作用域决定了代码里的变量和其他资源在各个区域中的可见性。 为什么需要作用域？最小访问原则那么，限制变量的可见性，不允许代码中所有的东西在任意地方都可用的好处是什么？ 其中一个优势，是作用域为代码提供了一个安全层级。计算机安全中，有个常规的原则是：用户只能访问他们当前需要的东西。 想想计算机管理员吧。他们在公司各个系统上拥有很多控制权，看起来甚至可以给予他们拥有全部权限的账号。假设你有一家公司，拥有三个管理员，他们都有系统的全部访问权限，并且一切运转正常。但是突然发生了一点意外，你的一个系统遭到恶意病毒攻击。现在你不知道这谁出的问题了吧？你这才意识到你应该只给他们基本用户的账号，并且只在需要时赋予他们完全的访问权。这能帮助你跟踪变化并记录每个人的操作。这叫做最小访问原则。眼熟吗？这个原则也应用于编程语言设计，在大多数编程语言（包括 JavaScript）中称为作用域。 在编程旅途中，作用域在代码中可以提升性能，跟踪 bug 并减少 bug。作用域还解决不同范围的同名变量命名问题。记住不要弄混作用域和上下文。它们是不同的特性！ JavaScript中的作用域在 JavaScript 中有两种作用域 全局作用域 局部作用域 当变量定义在一个函数中时，变量就在局部作用域中，而定义在函数之外的变量则从属于全局作用域。每个函数在调用的时候会创建一个新的作用域。 全局作用域当在文档中（document）编写 JavaScript 时，就已经在全局作用域中了。JavaScript 文档中（document）只有一个全局作用域。定义在函数之外的变量会被保存在全局作用域中。 12// the scope is by default globalvar name = &#x27;Hammad&#x27;; 全局作用域里的变量能够在其他作用域中被访问和修改。 123456789var name = &#x27;Hammad&#x27;; console.log(name); // logs &#x27;Hammad&#x27; function logName() &#123; console.log(name); // &#x27;name&#x27; is accessible here and everywhere else&#125; logName(); // logs &#x27;Hammad&#x27; 局部作用域定义在函数中的变量就在局部作用域中。并且函数在每次调用时都有一个不同的作用域。这意味着同名变量可以用在不同的函数中。因为这些变量绑定在不同的函数中，拥有不同作用域，彼此之间不能访问。 12345678910111213// Global Scopefunction someFunction() &#123; // Local Scope ##1 function someOtherFunction() &#123; // Local Scope ##2 &#125;&#125; // Global Scopefunction anotherFunction() &#123; // Local Scope ##3&#125;// Global Scope 块语句块级声明包括if和switch，以及for和while循环，和函数不同，它们不会创建新的作用域。在块级声明中定义的变量从属于该块所在的作用域。 123456if (true) &#123; // this &#x27;if&#x27; conditional block doesn&#x27;t create a new scope var name = &#x27;Hammad&#x27;; // name is still in the global scope&#125; console.log(name); // logs &#x27;Hammad&#x27; ECMAScript 6 引入了let和const关键字。这些关键字可以代替var。 1234var name = &#x27;Hammad&#x27;; let likes = &#x27;Coding&#x27;;const skills = &#x27;Javascript and PHP&#x27;; 和var关键字不同，let和const关键字支持在块级声明中创建使用局部作用域。 1234567891011121314if (true) &#123; // this &#x27;if&#x27; conditional block doesn&#x27;t create a scope // name is in the global scope because of the &#x27;var&#x27; keyword var name = &#x27;Hammad&#x27;; // likes is in the local scope because of the &#x27;let&#x27; keyword let likes = &#x27;Coding&#x27;; // skills is in the local scope because of the &#x27;const&#x27; keyword const skills = &#x27;JavaScript and PHP&#x27;;&#125; console.log(name); // logs &#x27;Hammad&#x27;console.log(likes); // Uncaught ReferenceError: likes is not definedconsole.log(skills); // Uncaught ReferenceError: skills is not defined 一个应用中全局作用域的生存周期与该应用相同。局部作用域只在该函数调用执行期间存在。 上下文我们经常弄混作用域和上下文，似乎两者是一个概念。但并非如此。作用域是我们上面讲到的那些，而上下文通常涉及到代码某些特殊部分中的this值。作用域指的是变量的可见性，而上下文指的是在相同的作用域中的this的值。我们当然也可以使用函数方法改变上下文，这个之后我们再讨论。在全局作用域中，上下文总是 Window 对象。 123456789// logs: Window &#123;speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage…&#125;console.log(this); function logFunction() &#123; console.log(this);&#125;// logs: Window &#123;speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage…&#125;// because logFunction() is not a property of an objectlogFunction(); 如果作用域定义在一个对象的方法中，上下文就是这个方法所在的那个对象。 1234567class User &#123; logName() &#123; console.log(this); &#125;&#125; (new User).logName(); // logs User &#123;&#125; (new User).logName()是创建对象关联到变量并调用logName方法的一种简便形式。通过这种方式我们并不需要创建一个新的变量。 可能注意到一点，就是如果使用new关键字调用函数时上下文的值会有差异。上下文会设置为被调用的函数的实例。考虑一下上面的这个例子，用new关键字调用的函数。 12345function logFunction() &#123; console.log(this);&#125; new logFunction(); // logs logFunction &#123;&#125; 当在严格模式（strict mode）中调用函数时，上下文默认是 undefined。 执行环境为了解决掉我们从上面学习中会出现的各种困惑，“执行环境（context）”这个词中的“环境（context）”指的是作用域而并非上下文。这是一个怪异的命名约定，但由于 JavaScript 的文档如此，我们只好也这样约定。 JavaScript 是一种单线程语言，所以它同一时间只能执行单个任务。其他任务排列在执行环境中。当 JavaScript 解析器开始执行你的代码，环境（作用域）默认设为全局。全局环境添加到你的执行环境中，事实上这是执行环境里的第一个环境。 之后，每个函数调用都会添加它的环境到执行环境中。无论是函数内部还是其他地方调用函数，都会是相同的过程。 每个函数都会创建它自己的执行环境。 当浏览器执行完环境中的代码，这个环境会从执行环境中弹出，执行环境中当前环境的状态会转移到父级环境。浏览器总是先执行在执行栈顶的执行环境（事实上就是你代码最里层的作用域）。 全局环境只能有一个，函数环境可以有任意多个。 执行环境有两个阶段：创建和执行。 创建阶段 第一阶段是创建阶段，是函数刚被调用但代码并未执行的时候。创建阶段主要发生了 3 件事。 创建变量对象 创建作用域链 设置上下文（this）的值 变量对象 变量对象（Variable Object）也称为活动对象（activation object），包含所有变量、函数和其他在执行环境中定义的声明。当函数调用时，解析器扫描所有资源，包括函数参数、变量和其他声明。当所有东西装填进一个对象，这个对象就是变量对象。 123&#x27;variableObject&#x27;: &#123; // contains function arguments, inner variable and function declarations&#125; 作用域链 在执行环境创建阶段，作用域链在变量对象之后创建。作用域链包含变量对象。作用域链用于解析变量。当解析一个变量时，JavaScript 开始从最内层沿着父级寻找所需的变量或其他资源。作用域链包含自己执行环境以及所有父级环境中包含的变量对象。 123&#x27;scopeChain&#x27;: &#123; // contains its own variable object and other variable objects of the parent execution contexts&#125; 执行环境对象 执行环境可以用下面抽象对象表示： 12345executionContextObject = &#123; &#x27;scopeChain&#x27;: &#123;&#125;, // contains its own variableObject and other variableObject of the parent execution contexts &#x27;variableObject&#x27;: &#123;&#125;, // contains function arguments, inner variable and function declarations &#x27;this&#x27;: valueOfThis&#125; 代码执行阶段 执行环境的第二个阶段就是代码执行阶段，进行其他赋值操作并且代码最终被执行。 词法作用域词法作用域的意思是在函数嵌套中，内层函数可以访问父级作用域的变量等资源。这意味着子函数词法绑定到了父级执行环境。词法作用域有时和静态作用域有关。 12345678910111213function grandfather() &#123; var name = &#x27;Hammad&#x27;; // likes is not accessible here function parent() &#123; // name is accessible here // likes is not accessible here function child() &#123; // Innermost level of the scope chain // name is also accessible here var likes = &#x27;Coding&#x27;; &#125; &#125;&#125; 你可能注意到了词法作用域是向前的，意思是子执行环境可以访问name。但不是由父级向后的，意味着父级不能访问likes。这也告诉了我们，在不同执行环境中同名变量优先级在执行栈由上到下增加。一个变量和另一个变量同名，内层函数（执行栈顶的环境）有更高的优先级。 闭包闭包的概念和我们刚学习的词法作用域紧密相关。当内部函数试着访问外部函数的作用域链（词法作用域之外的变量）时产生闭包。闭包包括它们自己的作用域链、父级作用域链和全局作用域。 闭包不仅能访问外部函数的变量，也能访问外部函数的参数。 即使函数已经return，闭包仍然能访问外部函数的变量。这意味着return的函数允许持续访问外部函数的所有资源。 当你的外部函数return一个内部函数，调用外部函数时return的函数并不会被调用。你必须先用一个单独的变量保存外部函数的调用，然后将这个变量当做函数来调用。看下面这个例子： 1234567891011121314function greet() &#123; name = &#x27;Hammad&#x27;; return function () &#123; console.log(&#x27;Hi &#x27; + name); &#125;&#125; greet(); // nothing happens, no errors // the returned function from greet() gets saved in greetLettergreetLetter = greet(); // calling greetLetter calls the returned function from the greet() functiongreetLetter(); // logs &#x27;Hi Hammad&#x27; 值得注意的是，即使在greet函数return后，greetLetter函数仍可以访问greet函数的name变量。如果不使用变量赋值来调用greet函数return的函数，一种方法是使用()两次()()，如下所示： 12345678function greet() &#123; name = &#x27;Hammad&#x27;; return function () &#123; console.log(&#x27;Hi &#x27; + name); &#125;&#125; greet()(); // logs &#x27;Hi Hammad&#x27; 使用 .call()， .apply() 和 .bind() 改变上下文Call 和 Apply 函数来改变函数调用时的上下文。这带给你神奇的编程能力（和终极统治世界的能力）。你只需要使用 call 和 apply 函数并把上下文当做第一个参数传入，而不是使用括号来调用函数。函数自己的参数可以在上下文后面传入。 1234567function hello() &#123; // do something...&#125; hello(); // the way you usually call ithello.call(context); // here you can pass the context(value of this) as the first argumenthello.apply(context); // here you can pass the context(value of this) as the first argument .call()和.apply()的区别是 Call 中其他参数用逗号分隔传入，而 Apply 允许你传入一个参数数组。 12345678910111213141516function introduce(name, interest) &#123; console.log(&#x27;Hi! I&#x27;m &#x27;+ name +&#x27; and I like &#x27;+ interest +&#x27;.&#x27;); console.log(&#x27;The value of this is &#x27;+ this +&#x27;.&#x27;)&#125; introduce(&#x27;Hammad&#x27;, &#x27;Coding&#x27;); // the way you usually call itintroduce.call(window, &#x27;Batman&#x27;, &#x27;to save Gotham&#x27;); // pass the arguments one by one after the contexttintroduce.apply(&#x27;Hi&#x27;, [&#x27;Bruce Wayne&#x27;, &#x27;businesses&#x27;]); // pass the arguments in an array after the context // Output:// Hi! I&#x27;m Hammad and I like Coding.// The value of this is [object Window].// Hi! I&#x27;m Batman and I like to save Gotham.// The value of this is [object Window].// Hi! I&#x27;m Bruce Wayne and I like businesses.// The value of this is Hi. Call 比 Apply 的效率高一点。 下面这个例子列举文档中所有项目，然后依次在控制台打印出来。 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Things to learn&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Things to Learn to Rule the World&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Learn PHP&lt;/li&gt; &lt;li&gt;Learn Laravel&lt;/li&gt; &lt;li&gt;Learn JavaScript&lt;/li&gt; &lt;li&gt;Learn VueJS&lt;/li&gt; &lt;li&gt;Learn CLI&lt;/li&gt; &lt;li&gt;Learn Git&lt;/li&gt; &lt;li&gt;Learn Astral Projection&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // Saves a NodeList of all list items on the page in listItems var listItems = document.querySelectorAll(&#x27;ul li&#x27;); // Loops through each of the Node in the listItems NodeList and logs its content for (var i = 0; i &lt; listItems.length; i++) &#123; (function () &#123; console.log(this.innerHTML); &#125;).call(listItems[i]); &#125; // Output logs: // Learn PHP // Learn Laravel // Learn JavaScript // Learn VueJS // Learn CLI // Learn Git // Learn Astral Projection &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML文档中仅包含一个无序列表。JavaScript 从 DOM 中选取它们。列表项会被从头到尾循环一遍。在循环时，我们把列表项的内容输出到控制台。 输出语句包含在由括号包裹的函数中，然后调用call函数。相应的列表项传入 call 函数，确保控制台输出正确对象的 innerHTML。 对象可以有方法，同样函数对象也可以有方法。事实上，JavaScript 函数有 4 个内置方法： Function.prototype.apply() Function.prototype.bind() (Introduced in ECMAScript 5 (ES5)) Function.prototype.call() Function.prototype.toString() Function.prototype.toString()返回函数代码的字符串表示。 到现在为止，我们讨论了.call()、.apply()和toString()。与 Call 和 Apply 不同，Bind 并不是自己调用函数，它只是在函数调用之前绑定上下文和其他参数。在上面提到的例子中使用 Bind： 12345678(function introduce(name, interest) &#123; console.log(&#x27;Hi! I&#x27;m &#x27;+ name +&#x27; and I like &#x27;+ interest +&#x27;.&#x27;); console.log(&#x27;The value of this is &#x27;+ this +&#x27;.&#x27;)&#125;).bind(window, &#x27;Hammad&#x27;, &#x27;Cosmology&#x27;)(); // logs:// Hi! I&#x27;m Hammad and I like Cosmology.// The value of this is [object Window]. Bind 像call函数一样用逗号分隔其他传入参数，不像apply那样用数组传入参数。","categories":[],"tags":[{"name":"作用域","slug":"作用域","permalink":"http://yoursite.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"}]},{"title":"函数的继承","slug":"函数的继承","date":"2018-08-17T12:18:41.000Z","updated":"2020-09-08T10:18:00.807Z","comments":true,"path":"2018/08/17/函数的继承/","link":"","permalink":"http://yoursite.com/2018/08/17/%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF/","excerpt":"","text":"说说对象之间的“继承”的五种方法。 比如，现在有一个“动物”对象的构造函数。 123function Animal()&#123; this.species = &quot;动物&quot;;&#125; 还有一个“猫”对象的构造函数。 1234function Cat(name,color)&#123; this.name = name; this.color = color;&#125; 怎样才能使“猫”继承“动物”呢？ 1、构造函数绑定第一种方法也是最简单的方法，使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行： 1234567function Cat(name,color)&#123; Animal.apply(this, arguments); this.name = name; this.color = color;&#125;var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);alert(cat1.species); // 动物 2、prototype模式第二种方法更常见，使用prototype属性。 如果”猫”的prototype对象，指向一个Animal的实例，那么所有”猫”的实例，就能继承Animal了。 1234Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);alert(cat1.species); // 动物 代码的第一行，我们将Cat的prototype对象指向一个Animal的实例。 1Cat.prototype = new Animal(); 它相当于完全删除了prototype 对象原先的值，然后赋予一个新值。但是，第二行又是什么意思呢？ 1Cat.prototype.constructor = Cat; 原来，任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有”Cat.prototype = new Animal();”这一行，Cat.prototype.constructor是指向Cat的；加了这一行以后，Cat.prototype.constructor指向Animal。 1alert(Cat.prototype.constructor == Animal); //true 更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。 1alert(cat1.constructor == Cat.prototype.constructor); // true 因此，在运行”Cat.prototype = new Animal();”这一行之后，cat1.constructor也指向Animal！ 1alert(cat1.constructor == Animal); // true 这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。 这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了prototype对象， 1o.prototype = &#123;&#125;; 那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。 1o.prototype.constructor = o; 3、直接继承prototype第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。 现在，我们先将Animal对象改写： 12function Animal()&#123; &#125;Animal.prototype.species = &quot;动物&quot;; 然后，将Cat的prototype对象，然后指向Animal的prototype对象，这样就完成了继承。 1234Cat.prototype = Animal.prototype;Cat.prototype.constructor = Cat;var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);alert(cat1.species); // 动物 与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。 所以，上面这一段代码其实是有问题的。请看第二行 1Cat.prototype.constructor = Cat; 这一句实际上把Animal.prototype对象的constructor属性也改掉了！ 1alert(Animal.prototype.constructor); // Cat 4、利用空对象作为中介","categories":[],"tags":[{"name":"prototype  object","slug":"prototype-object","permalink":"http://yoursite.com/tags/prototype-object/"}]},{"title":"HTML插入图片与CSS背景图片的区别","slug":"插入图片与背景图片的区别","date":"2017-08-12T06:37:10.000Z","updated":"2020-09-08T10:17:48.385Z","comments":true,"path":"2017/08/12/插入图片与背景图片的区别/","link":"","permalink":"http://yoursite.com/2017/08/12/%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E4%B8%8E%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"1、插入图片img为行内块元素，是一个盒子模型，占文档流的位置，图片加载出错时会出现红叉； ​ 背景图片不占文档流，在图片加载失败时，不会有占位标记，图片加载出错时不会出现红叉。 2、插入图片移动位置通过margin 和 padding实现； ​ 背景图片移动通过background-position移动。 3、插入图片更改大小通过width 和 height实现； ​ 背景图片只能通过background-size。 4、插入图片一般用在产片展示类，背景图片用于小图标背景或者超大背景图片。 5、盒子中使用背景图片需要注意盒子尺寸和背景图片尺寸匹配。 6、直接插入图片会多出4px，设置背景图片给定高度不会 ​ 去除图片底侧缝隙(低版本浏览器)： ​ 解决方法一：给img添加display: block; 转换为块级元素 ​ 解决方法二：给img添加vertical-align: middle | top 7、css中的图片以背景图形式存在，写在html中的图片以标签形式存在。在网页加载过程中，以css背景存在的图片会等到html结构加载完成才开始加载； 而html中的img标签是网页结构（内容）的一部分会在加载结构的过程中加载。 8、在一个单纯由HTML和CSS组成的页面中，背景图片总是最后加载的，那么假若想要使用较小的背景图片作为占位符，用于在加载较大的图片或者Flash文件时给用户以提示，大部分时候恐怕是达不到效果的，因为背景图片有时甚至会在大图片或Flash文件加载完成之后才会被加载。 9、通常非内容的图片（即用来修饰页面的元素）就写在css里，如果是内容性的图片就写在html中。比如，你要做一个漂亮相框的相册，那么修饰边框的图片就写在css里，相框里的内容照片就写在html中。","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"babel vue-cli vue","slug":"babel-vue-cli-vue","permalink":"http://yoursite.com/tags/babel-vue-cli-vue/"},{"name":"原型","slug":"原型","permalink":"http://yoursite.com/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"},{"name":"this","slug":"this","permalink":"http://yoursite.com/tags/this/"},{"name":"作用域","slug":"作用域","permalink":"http://yoursite.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"prototype  object","slug":"prototype-object","permalink":"http://yoursite.com/tags/prototype-object/"}]}